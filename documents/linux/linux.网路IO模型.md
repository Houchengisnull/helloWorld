[toc]

​	

# I/O模型

## 阻塞式I/O

阻塞式I/O模型。

![image-20220428213716143](..\images\net\blockingio.png)

进程会一直阻塞，直到数据拷贝完成。

### Blocking I/O网络通信模型

![image-20220429215340537](..\images\net\biomodel.png)

一个客户端连接对应一个线程，在连接数较多情况下，系统资源占用大。

### 伪异步I/O模型

![image-20220429215421300](..\images\net\noniomodel.png)

通过线程池实现伪异步IO：

- 实现简单
- 异步响应
- 控制线程资源

## 非阻塞I/O

![image-20220428213843262](..\images\net\nonblockingio.png)

## I/O复用

![image-20220428214058671](..\images\net\reproducibleio.png)

相比阻塞式IO模型的优势：

- 由一个线程检测多个网络通讯。

### select,poll,epoll

select,poll,epoll都是操作系统实现IO多路复用的机制。

| 方式   | 最大连接数                   | FD剧增后带来的IO效率问题                                     | 消息传递方式                   |
| ------ | ---------------------------- | ------------------------------------------------------------ | ------------------------------ |
| select |                              | 由于每次调用对连接进行线性遍历，所以随着FD增加时，性能线性下降 | 由内核拷贝                     |
| poll   | 基于链表实现，理论没有限制。 | 同上                                                         | 同上                           |
| epoll  |                              | 仅检测活跃的FD                                               | 通过内核与用户空间共享内存实现 |

[^fd]:file descriptor.

## 信号驱动I/O

![image-20220428214623151](..\images\net\sigio.png)

socket需要按照一个信号处理函数，进程继续运行并不阻塞。

当数据准备好后，进程会收到一个信号，可以在信号处理函数中调用I/O函数处理数据。

## 异步I/O

![image-20220428214824429](..\images\net\asynxio.png)

异步I/O模型[^AI/O]，当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出。

> linux系统中并没有真正实现AIO，而是一种伪AIO。

