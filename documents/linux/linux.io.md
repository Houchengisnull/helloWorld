[toc]

​	

# 网络I/O模型

在UNIX系统下，有五种常见的I/O模型：

- 同步阻塞式I/O
- 同步非阻塞I/O
- I/O多路复用
- 信号驱动I/O
- 异步I/O

## 同步阻塞式I/O

![image-20220428213716143](..\images\net\blockingio.png)

这种网络模型通常是我们编程最早接触的。比如在Java中的InputStream，OutputStream及它们的派生类。

它们的特点是：当线程调用了读操作(read/recv)后，操作系统将检查数据报是否准备就绪，若如果没有就绪，线程将会一直处于等待状态，<u>直到操作系统将数据从内核拷贝到用户空间。</u>。

### 阻塞式I/O模型

![image-20220429215340537](..\images\net\biomodel.png)

服务端每接收一个客户端连接，就需要为这个连接启动一个线程，让这个线程负责对这个连接的通信。

在连接数较多情况下，系统资源占用大。

### 伪异步I/O模型

![image-20220429215421300](..\images\net\noniomodel.png)

通过线程池实现伪异步I/O：

- 实现简单
- 异步响应
- 控制线程资源

与最基础的同步阻塞式I/O模型相比，伪异步I/O最大的优势在于能够控制线程资源。

## 同步非阻塞式I/O

![image-20220428213843262](..\images\net\nonblockingio.png)



同步非阻塞式I/O的原理也非常简单，就是将Socket设置为非阻塞。

当所请求的I/O操作无法完成时，并不会使线程进入睡眠，而是返回一个错误。这样当数据未就绪时，可以跳过等待步骤，执行下一步任务。

并结合轮询的方式，来执行检查数据报是否准备就绪。

## I/O多路复用

![image-20220428214058671](..\images\net\reproducibleio.png)

相比阻塞式IO模型的优势：

- 由一个线程检测多个网络通讯。

在IO多路复用模型中，很明显增加了一个`返回可读条件`的过程。操作系统内核将会通知应用程序“数据准备就绪”。收到这个通知后，应用程序会读取缓冲区中的数据。

仔细对比一下`多线程+同步阻塞式I/O`：I/O多路复用模型对于单个连接并没有性能优势，甚至由于更多的操作[^更多的操作]性能有所下降，但是由于它通过一个select来处理多个连接，在连接数较多的情况下能节省更多的线程资源。

[^更多的操作]: 图中的select、recvfrom。

### select,poll,epoll

select,poll,epoll都是操作系统实现I/O多路复用的机制。

| 方式   | 最大连接数                   | FD剧增后带来的I/O效率问题                                    | 消息传递方式                   |
| ------ | ---------------------------- | ------------------------------------------------------------ | ------------------------------ |
| select |                              | 由于每次调用对连接进行线性遍历，所以随着FD增加时，性能线性下降 | 由内核拷贝                     |
| poll   | 基于链表实现，理论没有限制。 | 同上                                                         | 同上                           |
| epoll  |                              | 仅检测活跃的FD                                               | 通过内核与用户空间共享内存实现 |

[^fd]:file descriptor.

## 信号驱动I/O

![image-20220428214623151](..\images\net\sigio.png)

Socket需要按照一个信号处理函数，进程继续运行并不阻塞。

当数据准备好后，进程会收到一个信号，可以在信号处理函数中调用I/O函数处理数据。

## 异步I/O

![image-20220428214824429](..\images\net\asynxio.png)

异步I/O模型[^AI/O]，当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出。

> linux系统中并没有真正实现AI/O，而是一种伪AI/O。
