[toc]

# 目的

- 目的

  提高系统稳定性，减少垃圾回收的执行时间。

- 参考指标

  - Minor GC执行时间不超过50ms；
  - Minor GC执行频率超过每10秒执行一次；
  - Full GC执行时间不超过1s；
  - Full GC执行时间超过10分钟执行一次；

# 调优步骤

## 日志分析

1. 监视GC的状态；

2. 分析结果，判断是否需要优化；

3. 调整垃圾回收器类型，内存分配参数；

4. 不断分析和调整

5. 全面应用参数

   如果找到了最合适的参数，则将这些参数应用到所有服务器上，并进行后续跟踪。

## 阅读GC日志

主要关注`Minor GC`与`Full GC`的回收效率（回收前后的大小比较）、回收耗时。

## 项目启动GC优化

- 开启日志分析

  ``` shell
  -XX:+PrintGCDetails
  ```

- 检查是否发生`Full GC`或者多次`Minor GC`

### 针对Full GC

- 根据日志信息进行设置，比如`Metadata Space(元空间)`不足则调整：

  ``` shell
  # 将元空间设置为64M
  -XX:MetaspaceSize=64m
  ```

- 发生多次`Minor GC`

  若新生代发生多次垃圾回收，可以对新生代的大小与比重进行设置：

  ``` shell
  # 设置堆初始化大小
  -Xms500m
  # 增加新生代比重
  -Xmn400m
  ```

## 项目运行GC优化

### 压测工具

#### JMeter

##### 聚合报告

- **#Samples**	样例数
- **Average**	平均响应时间
- **Median**	中位数响应时间
- **90% Line**	90%样例响应时间
- **95% Line**	95%样例响应时间
- **99% Line**	99%样例响应时间
- **Min**	最小响应时间
- **Max**	最大响应时间
- Error	
- **Throughput**	吞吐量(次/秒)
- Received
- Sent

> GC调优对运行效率影响非常小。

## 常用策略

### 新生代

- 响应时间优先

  尽可能设大，直到接近系统的最低响应时间限制。在这种情况下，新生代收集发生的频率也是最小的，减少到达老年代的对象。

- 吞吐量优先

  尽可能设置大，因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上应用。

- 避免设置过小

  设置过小可能导致频繁触发`Minor GC`。

### 老年代

- 响应时间优先

  老年代使用并发收集器，所以其大小需要小心设置。一般需要考虑并发会话率与会话持续时间等一些参数，如果堆设置小了，可能会造成内存碎片，高回收频率以及应用暂停而使用传统的标记清除方式；

  如果堆设置过大，则需要较长的收集时间。优化方案一般需要考虑：

  - 并发垃圾收集信息
  - 持久代并发收集次数
  - 传统GC信息
  - 花费在新生代与老年代回收上的时间比例

- 吞吐量优先

  吞吐量优先一般有一个很大的新生代和较小的老年代，以减少中期对象，而在老年代中存放长期存活对象。



# GC常用参数

## 生产环境

``` shell
# 发生内存溢出时输出一个dump.core文件，记录当时的堆内存快照，默认关闭
-XX:-HeapDumpOnOutOfMemoryError
# 设置快照文件位置
-XX:HeapDumpPath=./java_pid<pid>.hprof
```

## 调优

建议仅在调优时设置。

``` shell
# 打印简单的GC信息参数
-XX:+PrintGC
# 打印详细的GC信息
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
# 设置GC日志路径
-Xlogger:$logpath
```

## 其他

``` shell
# 提取Heap在每次垃圾回收前后的使用情况
-XX:PrintHeapAtGC
# 在系统控制台信息中看到class的加载过程和具体class信息，分析类的加载顺序以及是否可以进行精简操作
-XX:TraceClassLoading
# 禁止运行期间显式调用System.gc()
-XX:+DisableExplicitGC
```

# 逃逸分析

- 逃逸条件
  1. 对象足够小；
  2. 对象仅存在方法中被引用，即未被返回；
  3. 设置相关JVM参数；

- 栈上分配

  JVM开启逃逸分析后，如果JVM分析出对象可以在栈上分配的话，那么该对象的生命周期就跟随线程，并不会将对象分配在堆中。

  这样将减少JVM垃圾回收的频率，极大提高性能。

- 相关参数

  ``` shell
  # 启用逃逸分析(默认开启)
  -XX:+DoEscapAnalysis
  # 标量替换(默认开启)
  -XX:+EliminateAllocations
  # 本地线程分配缓冲(默认开启)
  -XX:+UseTLAB
  ```
