[TOC]

# 数据库事务特性 ACID

- A 原子性 atomicity

  一个事务中的所有操作要么全部完成，要么全部不完成。

- C 一致性 consistency

  在事务开始之前和事务结束以后，数据库完整性没有被破坏。

- I 隔离性 isolation

  事务并发情况下防止事务由于交叉执行而导致数据不一。

- D 持久性 durability

  对数据的修改是永久的。

一致性是通过原子性、隔离性、持久性共同作用得到的结果。

# 数据库事务隔离级别 isolation

数据库事务的隔离级别有4个。

由低到高依次为

- Read uncommitted 
- Read committed 
- Repeatable read 
- Serializable

这四个级别可以逐个解决`脏读` 、`不可重复读` 、`幻读`这几类问题。

√: 可能出现    ×: 不会出现

|                  | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | √    | √          | √    |
| Read committed   | ×    | √          | √    |
| Repeatable read  | ×    | ×          | √    |
| Serializable     | ×    | ×          | ×    |

> 我们讨论隔离级别的场景，主要是在多个事务并发 的情况下，因此，接下来的讲解都围绕事务并发。

## Read uncommitted

- 场景

公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。

可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。

- 脏读

​	在`事务并发`情况下，存在修改事务与查询事务。

​	在执行修改事务的过程中，执行查询事务，之后回滚修改事务。

​	导致查询结果与实际结果不一致，这种情况我们称之为`脏读`。

## Read committed

`Read committed`避免`脏读`问题，但不能避免`不可重复度Repeatable read`问题。

- 场景

singo拿着工资卡去消费，系统读取到卡里确实有2000元。

而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，**并在 singo之前提交了事务**。

当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为什么扣款失败？

- 重复读

  在`事务并发`情况下，存在两个修改事务。其中一个事务执行结果导致另一个事务执行失败，即`重复读`。

> 大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。

## Repeatable read 

- 场景

当隔离级别设置为`Repeatable read`时，可以避免不可重复读。

当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始）。

singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。

- 幻读场景

singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。

有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元。

而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务。

随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出 现了幻觉，幻读就这样产生了。

> Mysql的默认隔离级别就是Repeatable read。

## Serializable 序列化

`Serializable`是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用。在该级别下，事务**顺序**执行，不仅可以避免脏读、不可重复读，还避免了幻像读。

# 脏读、幻读、不可重复读

## 脏读 [改中读]

脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

## 不可重复读 [改中改]

是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）
例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。

## 幻读 [读中改]

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象
发生了幻觉一样。
例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。

# 参考

https://blog.csdn.net/qq_41376740/article/details/81835713